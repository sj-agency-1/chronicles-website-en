---
export interface TocItem {
  targetId: string;
  chapterTitle?: string;
  chapterDescription: string;
}

interface Props {
  items: Array<TocItem>;
  mode: 'default' | 'auto';
  /** Optional vertical offset (in pixels) applied after centering. Positive moves element further down. */
  offset?: number;
}

const { items = [], mode = 'default', offset = 0 } = Astro.props;
---

<table-of-content
  class="table-of-content block relative"
  data-mode={mode}
  data-items={JSON.stringify(items)}
  data-offset={String(offset)}
>
  <ul id="toc-list" class="flex flex-col gap-5">
    {
      mode === 'default' &&
        items.map((item, index) => (
          <li
            class="toc-item flex items-center justify-between cursor-pointer transition-all duration-300 ease-in-out hover:opacity-70"
            data-target={item.targetId}
            data-index={index}
            role="button"
            tabindex="0"
            aria-controls={item.targetId}
          >
            <div class="flex-1">
              {item.chapterTitle && <div class="text-sm text-gray-600">{item.chapterTitle}</div>}
              <div class="font-heading text-black font-bold text-base">{item.chapterDescription}</div>
            </div>
            <div class="dot w-4 h-4 bg-black opacity-0 transition-opacity duration-300 ease-in-out" />
          </li>
        ))
    }
  </ul>
</table-of-content>

<script>
  interface TocItem {
    targetId: string;
    chapterTitle?: string;
    chapterDescription: string;
    element: HTMLHeadingElement | null;
  }

  class TableOfContent extends HTMLElement {
    // Properties
    tocItems: Array<TocItem>;
    tocListItems: NodeListOf<Element> | null;
    targetElements: (HTMLElement | null)[];
    ticking: boolean;
    scrollHandler: (() => void) | null;
    // pixels to offset after centering (can be negative)
    scrollOffset: number;

    // Bound event handlers for proper cleanup
    boundHandleScroll: () => void;
    boundHandleTocItemClick: (event: Event, index: number) => void;

    constructor() {
      super();
      this.tocItems = [];
      this.tocListItems = null;
      this.targetElements = [];
      this.ticking = false;

      // Bind event handlers
      this.boundHandleScroll = this.handleScroll.bind(this);
      this.boundHandleTocItemClick = this.handleTocItemClick.bind(this);
    }

    connectedCallback() {
      this.initializeTOC();
    }

    disconnectedCallback() {
      this.cleanup();
    }

    initializeTOC() {
      const mode = this.dataset.mode || 'default';
      const itemsData = this.dataset.items;
      // parse offset, default to 0
      this.scrollOffset = this.dataset.offset ? parseFloat(this.dataset.offset) || 0 : 0;
      const predefinedItems = itemsData ? JSON.parse(itemsData) : [];

      if (mode === 'auto') {
        this.tocItems = this.generateTOCFromHeadings();
        this.renderTOCItems();
      } else {
        this.tocItems = predefinedItems.map(
          (item: { targetId: string; chapterTitle?: string; chapterDescription: string }) => ({
            ...item,
            element: document.getElementById(item.targetId),
          })
        );
      }

      this.setupTOCInteractions();
    }

    generateTOCFromHeadings() {
      const HEADING_SELECTOR = 'h2, h3';
      const headings = document.querySelectorAll(HEADING_SELECTOR);
      const tocItems: Array<TocItem> = [];

      headings.forEach((heading) => {
        const headingText = heading.textContent?.trim() || '';

        // Split on first colon to separate chapter title from description
        const colonIndex = headingText.indexOf(':');

        let chapterTitle: string | undefined;
        let chapterDescription: string;

        if (colonIndex !== -1) {
          chapterTitle = headingText.substring(0, colonIndex).trim();
          chapterDescription = headingText.substring(colonIndex + 1).trim();
        } else {
          chapterDescription = headingText;
        }

        // console.log('Heading Text:', headingText);
        // If heading text starts with "Эпилог", show only "Эпилог" in the TOC
        if (headingText.startsWith('Эпилог')) {
          chapterTitle = 'Эпилог';
        }

        // Generate targetId or use existing ID
        let targetId = heading.id;
        if (!targetId) {
          targetId = chapterDescription
            .toLowerCase()
            .replace(/[^\w\sа-яА-Я-]/g, '')
            .replace(/\s+/g, '-')
            .replace(/--+/g, '-')
            .replace(/^-|-$/g, '');
          heading.id = targetId;
        }

        tocItems.push({
          targetId,
          chapterTitle,
          chapterDescription,
          element: heading,
        });
      });

      return tocItems;
    }

    renderTOCItems() {
      const tocList = this.querySelector('#toc-list');
      if (!tocList) return;

      tocList.innerHTML = '';

      this.tocItems.forEach((item, index) => {
        const li = document.createElement('li');
        li.className =
          'toc-item flex items-center justify-between cursor-pointer transition-all duration-300 ease-in-out hover:opacity-70';
        li.setAttribute('data-target', item.targetId);
        li.setAttribute('data-index', index.toString());
        li.setAttribute('role', 'button');
        li.setAttribute('tabindex', '0');
        li.setAttribute('aria-controls', item.targetId);

        li.innerHTML = `
          <div class="flex-1">
            ${item.chapterTitle ? `<div class="text-sm text-gray-600">${item.chapterTitle}</div>` : ''}
            <div class="font-heading text-black font-bold text-base">${item.chapterDescription}</div>
          </div>
          <div class="dot w-4 h-4 bg-black opacity-0 transition-opacity duration-300 ease-in-out"></div>
        `;

        tocList.appendChild(li);
      });
    }

    setupTOCInteractions() {
      this.tocListItems = this.querySelectorAll('.toc-item');
      this.targetElements = this.tocItems.map((item) => document.getElementById(item.targetId)).filter(Boolean);

      // Add scroll event listener
      window.addEventListener('scroll', this.boundHandleScroll, { passive: true });

      // Add click handlers to TOC items
      this.tocListItems.forEach((item: Element, index: number) => {
        item.addEventListener('click', (e: Event) => this.boundHandleTocItemClick(e, index));
      });

      // Initialize first active section
      this.findActiveSection();
    }

    handleScroll() {
      if (!this.ticking) {
        requestAnimationFrame(() => {
          this.findActiveSection();
          this.ticking = false;
        });
        this.ticking = true;
      }
    }

    handleTocItemClick(event: Event, index: number) {
      event.preventDefault();
      const targetElement = this.targetElements[index];
      if (targetElement) {
        // Compute scroll top so the element is centered in the viewport
        const offset = 300;
        const rect = targetElement.getBoundingClientRect();
        const elementTop = rect.top + window.scrollY;
        const elementHeight = rect.height;
        const viewportCenter = window.innerHeight / 2;
        const desiredTop = elementTop - viewportCenter + elementHeight / 2 + (this.scrollOffset || 0) + offset;

        window.scrollTo({ top: Math.max(0, desiredTop), behavior: 'smooth' });
      }
    }

    setActiveTocItem(index: number) {
      if (!this.tocListItems) return;

      this.tocListItems.forEach((item: Element, i: number) => {
        const indicator = item.querySelector('.dot');
        if (!indicator) return;

        if (i === index) {
          indicator.classList.remove('opacity-0');
          indicator.classList.add('opacity-100');
        } else {
          indicator.classList.remove('opacity-100');
          indicator.classList.add('opacity-0');
        }
      });
    }

    findActiveSection() {
      // Use viewport center to determine which section is active
      const scrollPosition = window.scrollY;
      const viewportCenterPos = scrollPosition + window.innerHeight / 2;

      for (let i = 0; i < this.targetElements.length; i++) {
        const element = this.targetElements[i];
        if (!element) continue;

        const rect = element.getBoundingClientRect();
        const top = rect.top + scrollPosition;
        const bottom = top + rect.height;

        // Handle last element when scrolled to bottom
        const buffer = 100;
        if (
          i === this.targetElements.length - 1 &&
          window.innerHeight + scrollPosition >= document.documentElement.scrollHeight - buffer
        ) {
          this.setActiveTocItem(i);
          return;
        }

        if (viewportCenterPos >= top && viewportCenterPos < bottom) {
          this.setActiveTocItem(i);
          return;
        }
      }
    }

    cleanup() {
      // Remove event listeners
      window.removeEventListener('scroll', this.boundHandleScroll);

      // Remove click handlers from TOC items
      if (this.tocListItems) {
        this.tocListItems.forEach((item: Element, index: number) => {
          item.removeEventListener('click', (e: Event) => this.boundHandleTocItemClick(e, index));
        });
      }
    }
  }

  // Register the custom element if not already defined
  if (!customElements.get('table-of-content')) {
    customElements.define('table-of-content', TableOfContent);
  }
</script>
